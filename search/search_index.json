{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Here you can read about the api of <code>meshnetworkx</code>.</p> <p>Provides the GraphZ class for storing a NetworkX graph in Zenoh.</p> Usage <p><code>import meshnetworkx as mx</code></p>"},{"location":"#src.meshnetworkx.GraphZ","title":"<code>GraphZ</code>","text":"<p>Represents a NetworkX graph stored in Zenoh.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>class GraphZ:\n    \"\"\"Represents a NetworkX graph stored in Zenoh.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the GraphZ object and connects to the Zenoh router.\"\"\"\n        cfg = zenoh.Config()\n\n        # tell zenoh to connect to local router,\n        # cause multicast scouting does not work in docker outside of linux host.\n        # cfg.insert_json5(\"connect/endpoints\", json.dumps([\"tcp/localhost:7447\"]))\n        cfg.insert_json5(\"connect/endpoints\", json.dumps(_get_endpoints()))\n\n        self._z = zenoh.open(cfg)\n\n    @staticmethod\n    def from_networkx(g: nx.Graph) -&gt; \"GraphZ\":\n        \"\"\"Creates a GraphZ object from a NetworkX graph.\n\n        Args:\n            g: A NetworkX graph.\n\n        Returns:\n            A GraphZ object.\n        \"\"\"\n        zg = GraphZ()\n        for node, data in g.nodes(data=True):\n            zg.add_node(node, **data)\n\n        for u, v, data in g.edges(data=True):\n            zg.add_edge(u, v, **data)\n\n        return zg\n\n    def to_networkx(self) -&gt; nx.Graph:\n        \"\"\"Converts the GraphZ object to a NetworkX graph.\n\n        Returns:\n            A NetworkX graph.\n        \"\"\"\n        g = nx.Graph()\n\n        for node, data in self.nodes(data=True):\n            g.add_node(node, **data)\n\n        # TODO: add edge view\n        for u, v, data in self.edges(data=True):\n            g.add_edge(u, v, **data)\n\n        return g\n\n    def add_node(self, node: Any, **attr) -&gt; None:\n        \"\"\"Adds a node to the GraphZ object.\n\n        Args:\n            node: The node to add.\n            attr: Additional attributes for the node.\n        \"\"\"\n        _try_str(node)\n        # if self.has_node(node):\n        #     raise MeshNetworkXError(f\"Node {node} already exists\")\n\n        data_dict = {}\n        data_dict.update(attr)\n\n        data_bytes = pickle.dumps(data_dict)\n        self._z.put(_totopic(node), data_bytes)\n        # TODO: instead wait till we can read it back\n        time.sleep(WAIT_TIME)\n\n    # edge stuff\n\n    def add_edge(self, u: Any, v: Any, **attr) -&gt; None:\n        \"\"\"Adds an edge to the GraphZ object.\n\n        Args:\n            u: The source node.\n            v: The target node.\n            attr: Additional attributes for the edge.\n        \"\"\"\n        _try_str(u)\n        _try_str(v)\n\n        # check if the nodes exist, else create them\n        if not self.has_node(u):\n            self.add_node(u)\n        if not self.has_node(v):\n            self.add_node(v)\n\n        data_dict = {}\n        data_dict.update(attr)\n        data_bytes = pickle.dumps(data_dict)\n\n        key = f\"{u}/to/{v}\" if u &lt; v else f\"{v}/to/{u}\"\n        self._z.put(_totopic(key), data_bytes)\n        # TODO: instead wait till we can read it back\n        time.sleep(WAIT_TIME)\n\n    def remove_edge(self, u: Any, v: Any) -&gt; None:\n        \"\"\"Removes an edge from the GraphZ object.\n\n        Args:\n            u: The source node.\n            v: The target node.\n        \"\"\"\n        _try_str(u)\n        _try_str(v)\n\n        # check if the edge exists\n        if not self.has_edge(u, v) or not self.has_edge(v, u):\n            raise MeshNetworkXError(f\"Edge {u} to {v} does not exist\")\n\n        key = f\"{u}/to/{v}\" if u &lt; v else f\"{v}/to/{u}\"\n        self._z.delete(_totopic(key))\n        time.sleep(WAIT_TIME)\n\n    def has_edge(self, u: Any, v: Any) -&gt; bool:\n        \"\"\"Checks if an edge exists in the GraphZ object.\n\n        Args:\n            u: The source node.\n            v: The target node.\n\n        Returns:\n            True if the edge exists, False otherwise.\n        \"\"\"\n        u = _try_str(u)\n        v = _try_str(v)\n\n        # sort key alphabetically\n        key = (u, v) if u &lt; v else (v, u)\n\n        return key in self.edges()\n\n    @property\n    def edges(self) -&gt; nx.classes.reportviews.EdgeView:\n        \"\"\"Returns a list of edges in the GraphZ object.\n\n        Returns:\n            A list of edges.\n        \"\"\"\n        edges = []\n\n        replies = self._z.get(\n            _totopic(\"*/to/*\"), handler=zenoh.handlers.DefaultHandler()\n        )\n        for reply in replies:\n            reply: zenoh.Reply\n            if not reply.ok:\n                raise MeshNetworkXError(f\"Error: {reply.err.payload.to_string()}\")\n\n            # the last part is the node name\n            u = str(reply.ok.key_expr).split(\"/\")[-1]\n            v = str(reply.ok.key_expr).split(\"/\")[-3]\n\n            edge_data = pickle.loads(reply.ok.payload.to_bytes())\n\n            edges.append((u, v, edge_data))\n\n        G = nx.Graph()\n        G.add_edges_from(edges)\n\n        return G.edges\n\n    @property\n    def adj(self) -&gt; dict[Any, dict[Any, dict[Any, Any]]]:\n        \"\"\"Returns the adjacency list of the GraphZ object.\n\n        Returns:\n            The adjacency list.\n        \"\"\"\n        adj = {}\n        replies = self._z.get(\n            _totopic(\"*/to/*\"), handler=zenoh.handlers.DefaultHandler()\n        )\n\n        for reply in replies:\n            reply: zenoh.Reply\n\n            if reply.err:\n                raise MeshNetworkXError(f\"Error: {reply.err.payload.to_string()}\")\n\n            if reply.ok:\n                # the last part is the node name\n                u = str(reply.ok.key_expr).split(\"/\")[-1]\n                v = str(reply.ok.key_expr).split(\"/\")[-3]\n\n                # add the edge to the adjacency list\n                if u not in adj:\n                    adj[u] = {}\n                adj[u][v] = {}\n                if v not in adj:\n                    adj[v] = {}\n                adj[v][u] = {}\n\n        return adj\n\n    def add_nodes_from(self, nodes: list[Any], **attr) -&gt; None:\n        \"\"\"Add nodes from a list of nodes.\n\n        Args:\n            nodes: The nodes to add.\n            **attr: The attributes to add to the nodes.\n        \"\"\"\n        for node in nodes:\n            self.add_node(node, **attr)\n\n    def remove_nodes_from(self, nodes: list[Any]) -&gt; None:\n        \"\"\"Removes nodes from the GraphZ object.\n\n        Args:\n            nodes: The nodes to remove.\n        \"\"\"\n        for node in nodes:\n            self.remove_node(node)\n\n    def remove_node(self, node: Any) -&gt; None:\n        \"\"\"Removes a node from the GraphZ object.\n\n        Args:\n            node: The node to remove.\n        \"\"\"\n        # check if the node exists\n        if not self.has_node(node):\n            raise MeshNetworkXError(f\"Node {node} does not exist\")\n\n        self._z.delete(_totopic(node))\n        self._z.delete(_totopic(f\"{node}/to/*\"))\n        self._z.delete(_totopic(f\"*/to/{node}\"))\n        time.sleep(WAIT_TIME)\n\n    def has_node(self, node: Any) -&gt; bool:\n        \"\"\"Checks if a node exists in the GraphZ object.\n\n        Args:\n            node: The node to check.\n\n        Returns:\n            True if the node exists, False otherwise.\n        \"\"\"\n        _try_str(node)\n        return str(node) in self.nodes()\n\n    # def nodes(self, data: bool = False) -&gt; dict[Any, Any] | set[Any]:\n    @property\n    def nodes(self) -&gt; NodeView:\n        \"\"\"Returns a list of nodes in the GraphZ object.\n\n        Args:\n            data: If True, returns a list of tuples containing nodes and their data.\n            If False, returns a list of nodes.\n\n        Returns:\n            A list of nodes or a list of tuples containing nodes and their data.\n        \"\"\"\n        nodes = {}\n\n        replies = self._z.get(_totopic(\"*\"), handler=zenoh.handlers.DefaultHandler())\n        for reply in replies:\n            reply: zenoh.Reply\n            if not reply.ok:\n                raise MeshNetworkXError(f\"Error: {reply.err.payload.to_string()}\")\n\n            # the last part is the node name\n            node = str(reply.ok.key_expr).split(\"/\")[-1]\n            node_data = pickle.loads(reply.ok.payload.to_bytes())\n\n            nodes[node] = node_data\n\n        return NodeView(nodes)\n\n    def clear(self) -&gt; None:\n        \"\"\"Clears all nodes from the GraphZ object.\"\"\"\n        self._z.delete(_totopic(\"**\"))\n        time.sleep(WAIT_TIME)\n\n    def close(self) -&gt; None:\n        \"\"\"Closes the connection to the Zenoh router.\"\"\"\n        self._z.close()\n\n    def __iter__(self):\n        \"\"\"Returns an iterator over the nodes in the GraphZ object.\n\n        Returns:\n            An iterator over the nodes.\n        \"\"\"\n        return iter(self.nodes())\n\n    def draw(self, block: bool = True) -&gt; None:\n        \"\"\"Draws the GraphZ object using NetworkX.\n\n        Args:\n            block: If True, blocks the drawing window. If False, does not block.\n        \"\"\"\n        nxg = self.to_networkx()\n        nx.draw(nxg)\n        plt.show(block=block)\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.adj","title":"<code>adj: dict[Any, dict[Any, dict[Any, Any]]]</code>  <code>property</code>","text":"<p>Returns the adjacency list of the GraphZ object.</p> <p>Returns:</p> Type Description <code>dict[Any, dict[Any, dict[Any, Any]]]</code> <p>The adjacency list.</p>"},{"location":"#src.meshnetworkx.GraphZ.edges","title":"<code>edges: nx.classes.reportviews.EdgeView</code>  <code>property</code>","text":"<p>Returns a list of edges in the GraphZ object.</p> <p>Returns:</p> Type Description <code>EdgeView</code> <p>A list of edges.</p>"},{"location":"#src.meshnetworkx.GraphZ.nodes","title":"<code>nodes: NodeView</code>  <code>property</code>","text":"<p>Returns a list of nodes in the GraphZ object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>If True, returns a list of tuples containing nodes and their data.</p> required <p>Returns:</p> Type Description <code>NodeView</code> <p>A list of nodes or a list of tuples containing nodes and their data.</p>"},{"location":"#src.meshnetworkx.GraphZ.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the GraphZ object and connects to the Zenoh router.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the GraphZ object and connects to the Zenoh router.\"\"\"\n    cfg = zenoh.Config()\n\n    # tell zenoh to connect to local router,\n    # cause multicast scouting does not work in docker outside of linux host.\n    # cfg.insert_json5(\"connect/endpoints\", json.dumps([\"tcp/localhost:7447\"]))\n    cfg.insert_json5(\"connect/endpoints\", json.dumps(_get_endpoints()))\n\n    self._z = zenoh.open(cfg)\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns an iterator over the nodes in the GraphZ object.</p> <p>Returns:</p> Type Description <p>An iterator over the nodes.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def __iter__(self):\n    \"\"\"Returns an iterator over the nodes in the GraphZ object.\n\n    Returns:\n        An iterator over the nodes.\n    \"\"\"\n    return iter(self.nodes())\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.add_edge","title":"<code>add_edge(u, v, **attr)</code>","text":"<p>Adds an edge to the GraphZ object.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Any</code> <p>The source node.</p> required <code>v</code> <code>Any</code> <p>The target node.</p> required <code>attr</code> <p>Additional attributes for the edge.</p> <code>{}</code> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def add_edge(self, u: Any, v: Any, **attr) -&gt; None:\n    \"\"\"Adds an edge to the GraphZ object.\n\n    Args:\n        u: The source node.\n        v: The target node.\n        attr: Additional attributes for the edge.\n    \"\"\"\n    _try_str(u)\n    _try_str(v)\n\n    # check if the nodes exist, else create them\n    if not self.has_node(u):\n        self.add_node(u)\n    if not self.has_node(v):\n        self.add_node(v)\n\n    data_dict = {}\n    data_dict.update(attr)\n    data_bytes = pickle.dumps(data_dict)\n\n    key = f\"{u}/to/{v}\" if u &lt; v else f\"{v}/to/{u}\"\n    self._z.put(_totopic(key), data_bytes)\n    # TODO: instead wait till we can read it back\n    time.sleep(WAIT_TIME)\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.add_node","title":"<code>add_node(node, **attr)</code>","text":"<p>Adds a node to the GraphZ object.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Any</code> <p>The node to add.</p> required <code>attr</code> <p>Additional attributes for the node.</p> <code>{}</code> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def add_node(self, node: Any, **attr) -&gt; None:\n    \"\"\"Adds a node to the GraphZ object.\n\n    Args:\n        node: The node to add.\n        attr: Additional attributes for the node.\n    \"\"\"\n    _try_str(node)\n    # if self.has_node(node):\n    #     raise MeshNetworkXError(f\"Node {node} already exists\")\n\n    data_dict = {}\n    data_dict.update(attr)\n\n    data_bytes = pickle.dumps(data_dict)\n    self._z.put(_totopic(node), data_bytes)\n    # TODO: instead wait till we can read it back\n    time.sleep(WAIT_TIME)\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.add_nodes_from","title":"<code>add_nodes_from(nodes, **attr)</code>","text":"<p>Add nodes from a list of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list[Any]</code> <p>The nodes to add.</p> required <code>**attr</code> <p>The attributes to add to the nodes.</p> <code>{}</code> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def add_nodes_from(self, nodes: list[Any], **attr) -&gt; None:\n    \"\"\"Add nodes from a list of nodes.\n\n    Args:\n        nodes: The nodes to add.\n        **attr: The attributes to add to the nodes.\n    \"\"\"\n    for node in nodes:\n        self.add_node(node, **attr)\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.clear","title":"<code>clear()</code>","text":"<p>Clears all nodes from the GraphZ object.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears all nodes from the GraphZ object.\"\"\"\n    self._z.delete(_totopic(\"**\"))\n    time.sleep(WAIT_TIME)\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.close","title":"<code>close()</code>","text":"<p>Closes the connection to the Zenoh router.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the connection to the Zenoh router.\"\"\"\n    self._z.close()\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.draw","title":"<code>draw(block=True)</code>","text":"<p>Draws the GraphZ object using NetworkX.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>bool</code> <p>If True, blocks the drawing window. If False, does not block.</p> <code>True</code> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def draw(self, block: bool = True) -&gt; None:\n    \"\"\"Draws the GraphZ object using NetworkX.\n\n    Args:\n        block: If True, blocks the drawing window. If False, does not block.\n    \"\"\"\n    nxg = self.to_networkx()\n    nx.draw(nxg)\n    plt.show(block=block)\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.from_networkx","title":"<code>from_networkx(g)</code>  <code>staticmethod</code>","text":"<p>Creates a GraphZ object from a NetworkX graph.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>Graph</code> <p>A NetworkX graph.</p> required <p>Returns:</p> Type Description <code>GraphZ</code> <p>A GraphZ object.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>@staticmethod\ndef from_networkx(g: nx.Graph) -&gt; \"GraphZ\":\n    \"\"\"Creates a GraphZ object from a NetworkX graph.\n\n    Args:\n        g: A NetworkX graph.\n\n    Returns:\n        A GraphZ object.\n    \"\"\"\n    zg = GraphZ()\n    for node, data in g.nodes(data=True):\n        zg.add_node(node, **data)\n\n    for u, v, data in g.edges(data=True):\n        zg.add_edge(u, v, **data)\n\n    return zg\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.has_edge","title":"<code>has_edge(u, v)</code>","text":"<p>Checks if an edge exists in the GraphZ object.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Any</code> <p>The source node.</p> required <code>v</code> <code>Any</code> <p>The target node.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the edge exists, False otherwise.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def has_edge(self, u: Any, v: Any) -&gt; bool:\n    \"\"\"Checks if an edge exists in the GraphZ object.\n\n    Args:\n        u: The source node.\n        v: The target node.\n\n    Returns:\n        True if the edge exists, False otherwise.\n    \"\"\"\n    u = _try_str(u)\n    v = _try_str(v)\n\n    # sort key alphabetically\n    key = (u, v) if u &lt; v else (v, u)\n\n    return key in self.edges()\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.has_node","title":"<code>has_node(node)</code>","text":"<p>Checks if a node exists in the GraphZ object.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Any</code> <p>The node to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the node exists, False otherwise.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def has_node(self, node: Any) -&gt; bool:\n    \"\"\"Checks if a node exists in the GraphZ object.\n\n    Args:\n        node: The node to check.\n\n    Returns:\n        True if the node exists, False otherwise.\n    \"\"\"\n    _try_str(node)\n    return str(node) in self.nodes()\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.remove_edge","title":"<code>remove_edge(u, v)</code>","text":"<p>Removes an edge from the GraphZ object.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Any</code> <p>The source node.</p> required <code>v</code> <code>Any</code> <p>The target node.</p> required Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def remove_edge(self, u: Any, v: Any) -&gt; None:\n    \"\"\"Removes an edge from the GraphZ object.\n\n    Args:\n        u: The source node.\n        v: The target node.\n    \"\"\"\n    _try_str(u)\n    _try_str(v)\n\n    # check if the edge exists\n    if not self.has_edge(u, v) or not self.has_edge(v, u):\n        raise MeshNetworkXError(f\"Edge {u} to {v} does not exist\")\n\n    key = f\"{u}/to/{v}\" if u &lt; v else f\"{v}/to/{u}\"\n    self._z.delete(_totopic(key))\n    time.sleep(WAIT_TIME)\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.remove_node","title":"<code>remove_node(node)</code>","text":"<p>Removes a node from the GraphZ object.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Any</code> <p>The node to remove.</p> required Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def remove_node(self, node: Any) -&gt; None:\n    \"\"\"Removes a node from the GraphZ object.\n\n    Args:\n        node: The node to remove.\n    \"\"\"\n    # check if the node exists\n    if not self.has_node(node):\n        raise MeshNetworkXError(f\"Node {node} does not exist\")\n\n    self._z.delete(_totopic(node))\n    self._z.delete(_totopic(f\"{node}/to/*\"))\n    self._z.delete(_totopic(f\"*/to/{node}\"))\n    time.sleep(WAIT_TIME)\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.remove_nodes_from","title":"<code>remove_nodes_from(nodes)</code>","text":"<p>Removes nodes from the GraphZ object.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list[Any]</code> <p>The nodes to remove.</p> required Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def remove_nodes_from(self, nodes: list[Any]) -&gt; None:\n    \"\"\"Removes nodes from the GraphZ object.\n\n    Args:\n        nodes: The nodes to remove.\n    \"\"\"\n    for node in nodes:\n        self.remove_node(node)\n</code></pre>"},{"location":"#src.meshnetworkx.GraphZ.to_networkx","title":"<code>to_networkx()</code>","text":"<p>Converts the GraphZ object to a NetworkX graph.</p> <p>Returns:</p> Type Description <code>Graph</code> <p>A NetworkX graph.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def to_networkx(self) -&gt; nx.Graph:\n    \"\"\"Converts the GraphZ object to a NetworkX graph.\n\n    Returns:\n        A NetworkX graph.\n    \"\"\"\n    g = nx.Graph()\n\n    for node, data in self.nodes(data=True):\n        g.add_node(node, **data)\n\n    # TODO: add edge view\n    for u, v, data in self.edges(data=True):\n        g.add_edge(u, v, **data)\n\n    return g\n</code></pre>"},{"location":"#src.meshnetworkx.MeshNetworkXError","title":"<code>MeshNetworkXError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>General exception for MeshNetworkX errors.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>class MeshNetworkXError(Exception):\n    \"\"\"General exception for MeshNetworkX errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"#src.meshnetworkx.NodeView","title":"<code>NodeView</code>","text":"<p>Provides a read only view for accessing node data in a dictionary-like manner.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>class NodeView:\n    \"\"\"Provides a read only view for accessing node data in a dictionary-like manner.\"\"\"\n\n    def __init__(self, node_data: dict[Any, Any]):\n        \"\"\"Initializes the NodeView object with node data.\n\n        Args:\n            node_data: A dictionary containing node data.\n        \"\"\"\n        self._node_data = node_data  # Dictionary to store node data\n\n    def __getitem__(self, key: Any):\n        \"\"\"Allow dictionary-like access.\"\"\"\n        return self._node_data[key]\n\n    def __setitem__(self, key: Any, value: Any):\n        \"\"\"Prevent assignment to the NodeView.\"\"\"\n        raise TypeError(\"NodeView object does not support item assignment\")\n\n    def __call__(self, data: bool = False):\n        \"\"\"Method-like access with optional arguments.\"\"\"\n        if data:\n            return self._node_data.items()  # Return nodes with data\n        return self._node_data.keys()  # Return just node identifiers\n</code></pre>"},{"location":"#src.meshnetworkx.NodeView.__call__","title":"<code>__call__(data=False)</code>","text":"<p>Method-like access with optional arguments.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def __call__(self, data: bool = False):\n    \"\"\"Method-like access with optional arguments.\"\"\"\n    if data:\n        return self._node_data.items()  # Return nodes with data\n    return self._node_data.keys()  # Return just node identifiers\n</code></pre>"},{"location":"#src.meshnetworkx.NodeView.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Allow dictionary-like access.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def __getitem__(self, key: Any):\n    \"\"\"Allow dictionary-like access.\"\"\"\n    return self._node_data[key]\n</code></pre>"},{"location":"#src.meshnetworkx.NodeView.__init__","title":"<code>__init__(node_data)</code>","text":"<p>Initializes the NodeView object with node data.</p> <p>Parameters:</p> Name Type Description Default <code>node_data</code> <code>dict[Any, Any]</code> <p>A dictionary containing node data.</p> required Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def __init__(self, node_data: dict[Any, Any]):\n    \"\"\"Initializes the NodeView object with node data.\n\n    Args:\n        node_data: A dictionary containing node data.\n    \"\"\"\n    self._node_data = node_data  # Dictionary to store node data\n</code></pre>"},{"location":"#src.meshnetworkx.NodeView.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Prevent assignment to the NodeView.</p> Source code in <code>src/meshnetworkx/__init__.py</code> <pre><code>def __setitem__(self, key: Any, value: Any):\n    \"\"\"Prevent assignment to the NodeView.\"\"\"\n    raise TypeError(\"NodeView object does not support item assignment\")\n</code></pre>"},{"location":"tests/","title":"Tests","text":"<p>Here you can read about the tests of <code>meshnetworkx</code>.</p>"},{"location":"tests/#tests.conftest","title":"<code>conftest</code>","text":"<p>This module contains pytest fixtures for testing meshnetworkx.</p>"},{"location":"tests/#tests.conftest.mnx_graph","title":"<code>mnx_graph()</code>","text":"<p>Fixture to create and teardown GraphZ instance.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture\ndef mnx_graph():\n    \"\"\"Fixture to create and teardown GraphZ instance.\"\"\"\n    g = mx.GraphZ()\n\n    # This should not be necessary,\n    # but just in case a previous test did not cleanup properly\n    g.clear()\n\n    yield g\n\n    g.clear()\n    g.close()\n</code></pre>"},{"location":"tests/#tests.test_graph","title":"<code>test_graph</code>","text":"<p>This module contains basic tests for the GraphZ class.</p>"},{"location":"tests/#tests.test_graph.test_add_edge","title":"<code>test_add_edge(mnx_graph)</code>","text":"<p>Test adding an edge to the graph.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_add_edge(mnx_graph):\n    \"\"\"Test adding an edge to the graph.\"\"\"\n    G = mnx_graph\n    G.add_edge(0, 1)\n    assert G.adj == {\"0\": {\"1\": {}}, \"1\": {\"0\": {}}}\n\n    with pytest.raises(TypeError):\n        G.add_edge(None, \"anything\")\n</code></pre>"},{"location":"tests/#tests.test_graph.test_add_edges_from","title":"<code>test_add_edges_from(self)</code>","text":"<p>Test adding edges from a list with various attributes.</p> Source code in <code>tests/test_graph.py</code> <pre><code>@pytest.mark.skip(\"TODO\")\ndef test_add_edges_from(self):\n    \"\"\"Test adding edges from a list with various attributes.\"\"\"\n    G = self.Graph()\n    G.add_edges_from([(0, 1), (0, 2, {\"weight\": 3})])\n    assert G.adj == {\n        0: {1: {}, 2: {\"weight\": 3}},\n        1: {0: {}},\n        2: {0: {\"weight\": 3}},\n    }\n    G = self.Graph()\n    G.add_edges_from([(0, 1), (0, 2, {\"weight\": 3}), (1, 2, {\"data\": 4})], data=2)\n    assert G.adj == {\n        0: {1: {\"data\": 2}, 2: {\"weight\": 3, \"data\": 2}},\n        1: {0: {\"data\": 2}, 2: {\"data\": 4}},\n        2: {0: {\"weight\": 3, \"data\": 2}, 1: {\"data\": 4}},\n    }\n\n    with pytest.raises(nx.NetworkXError):\n        G.add_edges_from([(0,)])  # too few in tuple\n    with pytest.raises(nx.NetworkXError):\n        G.add_edges_from([(0, 1, 2, 3)])  # too many in tuple\n    with pytest.raises(TypeError):\n        G.add_edges_from([0])  # not a tuple\n    with pytest.raises(ValueError):\n        G.add_edges_from([(None, 3), (3, 2)])  # None cannot be a node\n</code></pre>"},{"location":"tests/#tests.test_graph.test_add_node_simple","title":"<code>test_add_node_simple(mnx_graph)</code>","text":"<p>Test adding a node to the graph.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_add_node_simple(mnx_graph):\n    \"\"\"Test adding a node to the graph.\"\"\"\n    # Test adding a node to the graph\n    mnx_graph.add_node(\"node1\", color=\"blue\")\n    nodes = mnx_graph.nodes()\n    assert \"node1\" in nodes\n</code></pre>"},{"location":"tests/#tests.test_graph.test_add_node_with_attributes","title":"<code>test_add_node_with_attributes(mnx_graph)</code>","text":"<p>Test adding a node with attributes.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_add_node_with_attributes(mnx_graph):\n    \"\"\"Test adding a node with attributes.\"\"\"\n    # Test adding a node with attributes\n    WEIGHT = 5\n    mnx_graph.add_node(\"node2\", color=\"green\", weight=WEIGHT)\n    nodes = mnx_graph.nodes(data=True)\n    assert any(\n        node == \"node2\" and data[\"color\"] == \"green\" and data[\"weight\"] == WEIGHT\n        for node, data in nodes\n    )\n</code></pre>"},{"location":"tests/#tests.test_graph.test_add_nodes_from","title":"<code>test_add_nodes_from(mnx_graph)</code>","text":"<p>Test adding nodes from a list and removing some of them.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_add_nodes_from(mnx_graph):\n    \"\"\"Test adding nodes from a list and removing some of them.\"\"\"\n    G = mnx_graph\n    G.add_nodes_from(list(\"ABCDEFGHIJKL\"))\n    assert G.has_node(\"L\")\n    G.remove_nodes_from([\"H\", \"I\", \"J\", \"K\", \"L\"])\n    G.add_nodes_from([1, 2, 3, 4])\n    assert sorted(G.nodes(), key=str) == [\n        \"1\",\n        \"2\",\n        \"3\",\n        \"4\",\n        \"A\",\n        \"B\",\n        \"C\",\n        \"D\",\n        \"E\",\n        \"F\",\n        \"G\",\n    ]\n    # test __iter__\n    assert sorted(G, key=str) == [\"1\", \"2\", \"3\", \"4\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"]\n</code></pre>"},{"location":"tests/#tests.test_graph.test_clear","title":"<code>test_clear(mnx_graph, times)</code>","text":"<p>Test clearing all nodes from the graph.</p> Source code in <code>tests/test_graph.py</code> <pre><code>@pytest.mark.parametrize(\"times\", [1, 10, 100])\ndef test_clear(mnx_graph, times: int):\n    \"\"\"Test clearing all nodes from the graph.\"\"\"\n    # Test clearing all nodes\n    NR_NODES = 4\n\n    for _ in range(times):\n        mnx_graph.add_node(\"node1\")\n        mnx_graph.add_node(\"node2\")\n        mnx_graph.add_edge(\"node1\", \"node2\")\n        mnx_graph.add_edge(\"node3\", \"node4\")\n        assert len(mnx_graph.nodes()) == NR_NODES\n\n        mnx_graph.clear()\n        assert len(mnx_graph.nodes()) == 0\n</code></pre>"},{"location":"tests/#tests.test_graph.test_clear_orig","title":"<code>test_clear_orig(mnx_graph)</code>","text":"<p>Test clearing the graph and its attributes.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_clear_orig(mnx_graph):\n    \"\"\"Test clearing the graph and its attributes.\"\"\"\n    G = mnx_graph\n    G.add_node(1)\n    G.add_edge(1, 2, color=\"red\")\n    # G.graph[\"name\"] = \"K3\"\n    G.clear()\n    # assert list(G.nodes) == []  # FIXME: need to update NodeView so it works like this\n    assert list(G.nodes()) == []\n    assert G.adj == {}\n</code></pre>"},{"location":"tests/#tests.test_graph.test_duplicate_node_warning","title":"<code>test_duplicate_node_warning(mnx_graph)</code>","text":"<p>How do we handle adding a node with a key that already exists?</p> Source code in <code>tests/test_graph.py</code> <pre><code>@pytest.mark.skip(\"Not implemented\")\ndef test_duplicate_node_warning(mnx_graph):\n    \"\"\"How do we handle adding a node with a key that already exists?\"\"\"\n    mnx_graph.add_node(\"node10\", color=\"orange\")\n    mnx_graph.add_node(\"node10\", color=\"purple\")\n    raise AssertionError()\n</code></pre>"},{"location":"tests/#tests.test_graph.test_has_edge","title":"<code>test_has_edge(mnx_graph)</code>","text":"<p>Test checking if an edge exists in the graph.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_has_edge(mnx_graph):\n    \"\"\"Test checking if an edge exists in the graph.\"\"\"\n    G = mnx_graph\n    G.add_edge(1, 2)\n\n    # simple graph has bidirectional edges\n    assert G.has_edge(1, 2)\n    assert G.has_edge(2, 1)\n\n    assert not G.has_edge(3, 1)\n</code></pre>"},{"location":"tests/#tests.test_graph.test_has_node","title":"<code>test_has_node(mnx_graph)</code>","text":"<p>Test checking if a node exists in the graph.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_has_node(mnx_graph):\n    \"\"\"Test checking if a node exists in the graph.\"\"\"\n    G = mnx_graph\n    G.add_node(1)\n    assert G.has_node(1)\n    assert not G.has_node(2)\n</code></pre>"},{"location":"tests/#tests.test_graph.test_has_node_str","title":"<code>test_has_node_str(mnx_graph)</code>","text":"<p>Test checking if a node exists in the graph with a string.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_has_node_str(mnx_graph):\n    \"\"\"Test checking if a node exists in the graph with a string.\"\"\"\n    G = mnx_graph\n    G.add_node(\"1\")\n    assert G.has_node(\"1\")\n    assert not G.has_node(\"2\")\n</code></pre>"},{"location":"tests/#tests.test_graph.test_mnx_to_nx","title":"<code>test_mnx_to_nx()</code>","text":"<p>Test converting a GraphZ instance to a NetworkX graph.</p> Source code in <code>tests/test_graph.py</code> <pre><code>@pytest.mark.xfail(reason=\"Sorting of edges is not implemented yet.\")\ndef test_mnx_to_nx():\n    \"\"\"Test converting a GraphZ instance to a NetworkX graph.\"\"\"\n    G = mx.GraphZ()\n    G.add_nodes_from(list(\"ABCDEFGHIJKL\"))\n    # G.add_edge(\"A\", \"B\", color=\"purple\")\n    G.add_edge(\"B\", \"A\", color=\"purple\")\n\n    G2 = G.to_networkx()\n\n    assert sorted(G.nodes()) == sorted(G2.nodes())\n    assert sorted(G.edges()) == sorted(G2.edges())\n\n    G.clear()\n    G.close()\n</code></pre>"},{"location":"tests/#tests.test_graph.test_node_attribute_management","title":"<code>test_node_attribute_management(mnx_graph)</code>","text":"<p>Test adding nodes with various attributes and updating them correctly.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_node_attribute_management(mnx_graph):\n    \"\"\"Test adding nodes with various attributes and updating them correctly.\"\"\"\n    G = mnx_graph\n    G.add_node(0)\n\n    # TODO: enable adj\n    # FIXME: adj is not working as intended yet.\n    # With a single node it returns an empty dict, instead of an unconnected node.\n    # assert G.adj == {0: {}}\n\n    # test add attributes\n    G.add_node(1, c=\"red\")\n    G.add_node(2, c=\"blue\")\n    G.add_node(3, c=\"red\")\n    assert G.nodes[\"1\"][\"c\"] == \"red\"\n    assert G.nodes[\"2\"][\"c\"] == \"blue\"\n    assert G.nodes[\"3\"][\"c\"] == \"red\"\n    # test updating attributes\n    G.add_node(1, c=\"blue\")\n    G.add_node(2, c=\"red\")\n    G.add_node(3, c=\"blue\")\n    assert G.nodes[\"1\"][\"c\"] == \"blue\"\n    assert G.nodes[\"2\"][\"c\"] == \"red\"\n    assert G.nodes[\"3\"][\"c\"] == \"blue\"\n</code></pre>"},{"location":"tests/#tests.test_graph.test_node_view_assignment_raises_error","title":"<code>test_node_view_assignment_raises_error(mnx_graph)</code>","text":"<p>Test that assigning to the node view raises an error.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_node_view_assignment_raises_error(mnx_graph):\n    \"\"\"Test that assigning to the node view raises an error.\"\"\"\n    G = mnx_graph\n    G.add_node(1, color=\"red\")\n\n    with pytest.raises(TypeError):\n        G.nodes[1] = \"foo\"\n</code></pre>"},{"location":"tests/#tests.test_graph.test_node_view_data_assignment_raises_error","title":"<code>test_node_view_data_assignment_raises_error(mnx_graph)</code>","text":"<p>Test that assigning to the node view raises an error.</p> Source code in <code>tests/test_graph.py</code> <pre><code>@pytest.mark.skip(\"TODO: node data is still unprotected since it is a regular dict.\")\ndef test_node_view_data_assignment_raises_error(mnx_graph):\n    \"\"\"Test that assigning to the node view raises an error.\"\"\"\n    G = mnx_graph\n    G.add_node(1, color=\"red\")\n\n    # fails\n    with pytest.raises(TypeError):\n        G.nodes[\"1\"][\"color\"] = \"green\"\n</code></pre>"},{"location":"tests/#tests.test_graph.test_nodes_with_data","title":"<code>test_nodes_with_data(mnx_graph)</code>","text":"<p>Test getting nodes with attributes.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_nodes_with_data(mnx_graph):\n    \"\"\"Test getting nodes with attributes.\"\"\"\n    # Test getting nodes with attributes\n    mnx_graph.add_node(\"node10\", color=\"orange\")\n    mnx_graph.add_node(\"node11\", color=\"purple\")\n    nodes = mnx_graph.nodes(data=True)\n    assert any(node == \"node10\" and data[\"color\"] == \"orange\" for node, data in nodes)\n    assert any(node == \"node11\" and data[\"color\"] == \"purple\" for node, data in nodes)\n</code></pre>"},{"location":"tests/#tests.test_graph.test_nodes_without_data","title":"<code>test_nodes_without_data(mnx_graph)</code>","text":"<p>Test getting nodes without attributes.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_nodes_without_data(mnx_graph):\n    \"\"\"Test getting nodes without attributes.\"\"\"\n    # Test getting nodes without attributes\n    mnx_graph.add_node(\"node8\")\n    mnx_graph.add_node(\"node9\")\n    nodes = mnx_graph.nodes()\n    assert \"node8\" in nodes\n    assert \"node9\" in nodes\n</code></pre>"},{"location":"tests/#tests.test_graph.test_nx_to_mnx","title":"<code>test_nx_to_mnx()</code>","text":"<p>Test converting a NetworkX graph to a GraphZ instance.</p> Source code in <code>tests/test_graph.py</code> <pre><code>@pytest.mark.xfail(reason=\"Edges are not yet converted.\")\ndef test_nx_to_mnx():\n    \"\"\"Test converting a NetworkX graph to a GraphZ instance.\"\"\"\n    G = nx.Graph()\n    G.add_nodes_from(list(\"ABCDEFGHIJKL\"))\n    G.add_edge(\"A\", \"B\", color=\"purple\")\n\n    Z = mx.GraphZ.from_networkx(G)\n\n    assert sorted(G.nodes()) == sorted(Z.nodes())\n    assert sorted(G.edges()) == sorted(Z.edges())\n\n    Z.clear()\n    Z.close()\n</code></pre>"},{"location":"tests/#tests.test_graph.test_nx_to_mnx_to_nx_nodes_only","title":"<code>test_nx_to_mnx_to_nx_nodes_only()</code>","text":"<p>Test converting a NetworkX graph to a GraphZ instance and back to NetworkX.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_nx_to_mnx_to_nx_nodes_only():\n    \"\"\"Test converting a NetworkX graph to a GraphZ instance and back to NetworkX.\"\"\"\n    G = nx.Graph()\n    G.add_nodes_from(list(\"ABCDEFGHIJKL\"))\n    Z = mx.GraphZ.from_networkx(G)\n\n    G2 = Z.to_networkx()\n\n    assert sorted(G.nodes()) == sorted(G2.nodes())\n\n    Z.clear()\n    Z.close()\n</code></pre>"},{"location":"tests/#tests.test_graph.test_nx_to_zgraph_to_nx","title":"<code>test_nx_to_zgraph_to_nx()</code>","text":"<p>Test converting a NetworkX graph to a GraphZ instance and back to NetworkX.</p> Source code in <code>tests/test_graph.py</code> <pre><code>@pytest.mark.xfail(reason=\"Sorting of edges is somehow random.\")\ndef test_nx_to_zgraph_to_nx():\n    \"\"\"Test converting a NetworkX graph to a GraphZ instance and back to NetworkX.\"\"\"\n    G = nx.Graph()\n    G.add_edge(\"1\", \"2\", color=\"purple\")\n\n    Z = mx.GraphZ.from_networkx(G)\n    G2 = Z.to_networkx()\n\n    assert sorted(G.nodes()) == sorted(G2.nodes())\n    assert sorted(G.edges()) == sorted(G2.edges())\n\n    Z.clear()\n    Z.close()\n</code></pre>"},{"location":"tests/#tests.test_graph.test_nx_to_zgraph_to_nx_int","title":"<code>test_nx_to_zgraph_to_nx_int()</code>","text":"<p>Test converting a NetworkX graph to a GraphZ instance and back to NetworkX.</p> Source code in <code>tests/test_graph.py</code> <pre><code>@pytest.mark.skip(\n    \"Because we convert the node data to a string, cannot compare the data.\"\n)\ndef test_nx_to_zgraph_to_nx_int():\n    \"\"\"Test converting a NetworkX graph to a GraphZ instance and back to NetworkX.\"\"\"\n    G = nx.Graph()\n    G.add_edge(\"1\", \"2\", color=\"purple\")\n\n    Z = mx.GraphZ.from_networkx(G)\n    G2 = Z.to_networkx()\n\n    assert sorted(G.nodes()) == sorted(G2.nodes())\n    assert sorted(G.edges()) == sorted(G2.edges())\n    Z.clear()\n    Z.close()\n</code></pre>"},{"location":"tests/#tests.test_graph.test_remove_edge","title":"<code>test_remove_edge(mnx_graph)</code>","text":"<p>Test removing an edge from the graph.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_remove_edge(mnx_graph):\n    \"\"\"Test removing an edge from the graph.\"\"\"\n    G = mnx_graph\n    G.add_edge(1, 2, weight=3)\n    assert G.adj == {\"1\": {\"2\": {}}, \"2\": {\"1\": {}}}\n    G.remove_edge(1, 2)\n    assert G.adj == {}\n    # TODO: (match nx) raise error when edge does not exist\n    with pytest.raises(mx.MeshNetworkXError):\n        G.remove_edge(-1, 0)\n</code></pre>"},{"location":"tests/#tests.test_graph.test_remove_edge_2","title":"<code>test_remove_edge_2(mnx_graph)</code>","text":"<p>Test removing an edge from the graph with multiple edges.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_remove_edge_2(mnx_graph):\n    \"\"\"Test removing an edge from the graph with multiple edges.\"\"\"\n    G = mnx_graph\n    G.add_edge(1, 2, weight=3)\n    assert G.adj == {\"1\": {\"2\": {}}, \"2\": {\"1\": {}}}\n    G.add_edge(0, 1, weight=2)\n    assert G.adj == {\"0\": {\"1\": {}}, \"1\": {\"2\": {}, \"0\": {}}, \"2\": {\"1\": {}}}\n    G.remove_edge(0, 1)\n    assert G.adj == {\"1\": {\"2\": {}}, \"2\": {\"1\": {}}}\n</code></pre>"},{"location":"tests/#tests.test_graph.test_remove_edges_from","title":"<code>test_remove_edges_from(self)</code>","text":"<p>Test removing edges from the graph.</p> Source code in <code>tests/test_graph.py</code> <pre><code>@pytest.mark.skip(\"TODO\")\ndef test_remove_edges_from(self):\n    \"\"\"Test removing edges from the graph.\"\"\"\n    G = self.K3.copy()\n    G.remove_edges_from([(0, 1)])\n    assert G.adj == {0: {2: {}}, 1: {2: {}}, 2: {0: {}, 1: {}}}\n    G.remove_edges_from([(0, 0)])  # silent fail\n</code></pre>"},{"location":"tests/#tests.test_graph.test_remove_node","title":"<code>test_remove_node(mnx_graph)</code>","text":"<p>Test removing a node from the graph.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_remove_node(mnx_graph):\n    \"\"\"Test removing a node from the graph.\"\"\"\n    # Test removing a node\n    mnx_graph.add_node(\"node3\")\n    nodes = mnx_graph.nodes()\n    assert \"node3\" in nodes\n\n    mnx_graph.remove_node(\"node3\")\n    nodes = mnx_graph.nodes()\n    assert \"node3\" not in nodes\n</code></pre>"},{"location":"tests/#tests.test_graph.test_remove_node_hardcore","title":"<code>test_remove_node_hardcore(mnx_graph)</code>","text":"<p>Test removing a node with edges from the graph.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_remove_node_hardcore(mnx_graph):\n    \"\"\"Test removing a node with edges from the graph.\"\"\"\n    G = mnx_graph\n    G.add_edge(1, 2)\n    assert G.adj == {\"1\": {\"2\": {}}, \"2\": {\"1\": {}}}\n    G.add_node(0)\n    G.remove_node(0)\n    assert G.adj == {\"1\": {\"2\": {}}, \"2\": {\"1\": {}}}\n    with pytest.raises(mx.MeshNetworkXError):\n        G.remove_node(-1)\n</code></pre>"},{"location":"tests/#tests.test_graph.test_removing_node_removes_edge","title":"<code>test_removing_node_removes_edge(mnx_graph)</code>","text":"<p>Test removing a node also removes its edges.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_removing_node_removes_edge(mnx_graph):\n    \"\"\"Test removing a node also removes its edges.\"\"\"\n    G = mnx_graph\n    G.add_edge(1, 2, weight=3)\n    assert G.adj == {\"1\": {\"2\": {}}, \"2\": {\"1\": {}}}\n    G.add_edge(0, 1, weight=2)\n    assert G.adj == {\"0\": {\"1\": {}}, \"1\": {\"2\": {}, \"0\": {}}, \"2\": {\"1\": {}}}\n    G.remove_node(0)\n    time.sleep(1)\n    assert G.adj == {\"1\": {\"2\": {}}, \"2\": {\"1\": {}}}\n</code></pre>"},{"location":"tests/#tests.test_graph.test_to_networkx","title":"<code>test_to_networkx(mnx_graph)</code>","text":"<p>Test converting GraphZ instance to NetworkX graph.</p> Source code in <code>tests/test_graph.py</code> <pre><code>def test_to_networkx(mnx_graph):\n    \"\"\"Test converting GraphZ instance to NetworkX graph.\"\"\"\n    # Test converting to NetworkX graph\n    mnx_graph.add_node(\"node6\", color=\"yellow\")\n    mnx_graph.add_node(\"node7\", color=\"red\")\n    g = mnx_graph.to_networkx()\n    assert isinstance(g, nx.Graph)\n    assert \"node6\" in g.nodes\n    assert g.nodes[\"node6\"][\"color\"] == \"yellow\"\n    assert \"node7\" in g.nodes\n    assert g.nodes[\"node7\"][\"color\"] == \"red\"\n</code></pre>"},{"location":"tests/#tests.test_graph.test_types_for_nodes","title":"<code>test_types_for_nodes(mnx_graph, input_data, error)</code>","text":"<p>Test that we can use different types for nodes.</p> Source code in <code>tests/test_graph.py</code> <pre><code>@pytest.mark.parametrize(\n    \"input_data, error\",\n    [\n        (1, None),\n        (\"1\", None),\n        (1.0, None),\n        (1j, None),\n        (True, None),\n        (False, None),\n        (None, TypeError),\n        (\"1.0\", None),\n        (\"1j\", None),\n        (\"True\", None),\n        (\"False\", None),\n        (\"None\", None),\n        (b\"1\", None),\n        (b\"True\", None),\n        (b\"False\", None),\n        (bytearray(b\"1\"), None),\n        (\"/\", mx.MeshNetworkXError),\n        (\"?\", mx.MeshNetworkXError),\n        (\"*\", mx.MeshNetworkXError),\n        (\"**\", mx.MeshNetworkXError),\n    ],\n)\ndef test_types_for_nodes(mnx_graph, input_data, error):\n    \"\"\"Test that we can use different types for nodes.\"\"\"\n    G = mnx_graph\n    if error:\n        with pytest.raises(error):\n            G.add_node(input_data)\n    else:\n        G.add_node(input_data)\n</code></pre>"},{"location":"tests/#tests.test_interface","title":"<code>test_interface</code>","text":"<p>Tests to ensure that the GraphZ interface matches the NetworkX Graph interface.</p>"},{"location":"tests/#tests.test_interface.test_graph_attributes","title":"<code>test_graph_attributes()</code>","text":"<p>Test that all attributes in NetworkX Graph are present in GraphZ.</p> Source code in <code>tests/test_interface.py</code> <pre><code>def test_graph_attributes():\n    \"\"\"Test that all attributes in NetworkX Graph are present in GraphZ.\"\"\"\n    nx_graph = nx.Graph()\n    graphz_graph = mx.GraphZ()\n\n    for attr in dir(nx_graph):\n        if (\n            not callable(getattr(nx_graph, attr))\n            and attr not in WHITELIST[\"attributes\"]\n        ):\n            assert hasattr(graphz_graph, attr), f\"Graphz is missing attribute: {attr}\"\n</code></pre>"},{"location":"tests/#tests.test_interface.test_graph_interface","title":"<code>test_graph_interface()</code>","text":"<p>Test that the GraphZ interface matches the NetworkX Graph interface.</p> Source code in <code>tests/test_interface.py</code> <pre><code>def test_graph_interface():\n    \"\"\"Test that the GraphZ interface matches the NetworkX Graph interface.\"\"\"\n    nx_graph = nx.Graph()\n    graphz_graph = mx.GraphZ()\n\n    # Check if both have the same methods\n    nx_methods = set(dir(nx_graph))\n    graphz_methods = set(dir(graphz_graph))\n\n    method_differences = (nx_methods - graphz_methods) - set(WHITELIST[\"methods\"])\n    _log_differences(method_differences, \"methods\")\n    assert (\n        not method_differences\n    ), \"Graphz interface does not match NetworkX Graph interface\"\n\n    # Check if both have the same attributes\n    nx_attrs = {attr for attr in nx_methods if not callable(getattr(nx_graph, attr))}\n    graphz_attrs = {\n        attr for attr in graphz_methods if not callable(getattr(graphz_graph, attr))\n    }\n\n    attr_differences = (nx_attrs - graphz_attrs) - set(WHITELIST[\"attributes\"])\n    _log_differences(attr_differences, \"attributes\")\n    assert (\n        not attr_differences\n    ), \"Graphz attributes do not match NetworkX Graph attributes\"\n</code></pre>"},{"location":"tests/#tests.test_interface.test_graph_methods","title":"<code>test_graph_methods()</code>","text":"<p>Test that all methods in NetworkX Graph are present in GraphZ.</p> Source code in <code>tests/test_interface.py</code> <pre><code>def test_graph_methods():\n    \"\"\"Test that all methods in NetworkX Graph are present in GraphZ.\"\"\"\n    nx_graph = nx.Graph()\n    graphz_graph = mx.GraphZ()\n\n    for method in dir(nx_graph):\n        if callable(getattr(nx_graph, method)) and method not in WHITELIST[\"methods\"]:\n            assert hasattr(graphz_graph, method), f\"Graphz is missing method: {method}\"\n</code></pre>"},{"location":"tests/#tests.test_mesh","title":"<code>test_mesh</code>","text":"<p>This module contains tests while running in multiple processes.</p>"},{"location":"tests/#tests.test_mesh.test_subprocess_communication","title":"<code>test_subprocess_communication(mnx_graph)</code>","text":"<p>Test communication in a subprocess.</p> Source code in <code>tests/test_mesh.py</code> <pre><code>def test_subprocess_communication(mnx_graph):\n    \"\"\"Test communication in a subprocess.\"\"\"\n    p = mp.Process(target=_start_and_write_graph)\n    p.start()\n    p.join()\n\n    assert mnx_graph.has_node(\"a\")\n    assert mnx_graph.nodes[\"a\"][\"color\"] == \"red\"\n</code></pre>"},{"location":"tests/#tests.test_mesh.test_subprocess_multiple_nodes","title":"<code>test_subprocess_multiple_nodes(mnx_graph)</code>","text":"<p>Test adding multiple nodes in a subprocess.</p> Source code in <code>tests/test_mesh.py</code> <pre><code>def test_subprocess_multiple_nodes(mnx_graph):\n    \"\"\"Test adding multiple nodes in a subprocess.\"\"\"\n    p = mp.Process(target=_start_and_add_multiple_nodes)\n    p.start()\n    p.join()\n\n    assert mnx_graph.has_node(\"a\")\n    assert mnx_graph.has_node(\"b\")\n    assert mnx_graph.has_node(\"c\")\n    assert mnx_graph.nodes[\"a\"][\"color\"] == \"red\"\n    assert mnx_graph.nodes[\"b\"][\"color\"] == \"blue\"\n    assert mnx_graph.nodes[\"c\"][\"color\"] == \"green\"\n</code></pre>"},{"location":"tests/#tests.test_mesh.test_subprocess_remove_node","title":"<code>test_subprocess_remove_node(mnx_graph)</code>","text":"<p>Test removing a node in a subprocess.</p> Source code in <code>tests/test_mesh.py</code> <pre><code>def test_subprocess_remove_node(mnx_graph):\n    \"\"\"Test removing a node in a subprocess.\"\"\"\n    mnx_graph.add_node(\"a\", color=\"red\")\n\n    p = mp.Process(target=_start_and_remove_node)\n    p.start()\n    p.join()\n\n    assert not mnx_graph.has_node(\"a\")\n</code></pre>"}]}